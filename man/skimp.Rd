% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/skimp.R
\name{skimp}
\alias{skimp}
\title{Title}
\usage{
skimp(
  data,
  window_sizes = seq.int(from = 10, to = length(data)/2, length.out = 20),
  plot = FALSE,
  pmp_obj = NULL
)
}
\arguments{
\item{data}{dataframe}

\item{window_sizes}{window sizes

The work closest in spirit to ours is VALMOD. The idea of VALMOD is to compute the MP for
the shortest length of interest, then use the information gleaned from it to guide a search
through longer subsequence lengths, exploiting lower bounds to prune off some calculations.
This idea works well for the first few of the longer subsequence lengths, but the lower bounds
progressively weaken, making the pruning ineffective. Thus, in the five case studies they
presented, the mean value of U/L was just 1.24. In contrast, consider that our termite example
in Fig. 15 has a U/L ratio of 240, more than two orders of magnitude larger. Thus, VALMOD is
perhaps best seen as finding motifs with some tolerance for a slightly (~25\%) too short
user-specified query length, rather than a true "motif-of-all-lengths" algorithm. Also note
that apart from the shortest length, VALMOD only gives some information for the other lengths,
unlike pmp, which contains exact distances for all subsequences of all lengths.}

\item{plot}{plot each interaction}

\item{pmp_res}{}
}
\value{
Returns the Pan Matrix Profile
}
\description{
Title
}
\examples{

# 1. upper_window will be set to Inf on new objects
# 1.1. upper_window will also be used for plot, and for discovery, it must not remove any existing data from the object
# 2. window_sizes is used for plot, it must not remove any mp inside the object
# 2.1. window_sizes tells the function what mp are stored, it may be updated with as.numeric(names(pmp))
# 3. the functions must be capable to handle the data without need to sort by window_size, but sort may be useful later(?)
}
